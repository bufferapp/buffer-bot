{
  "name": "rsvp",
  "version": "1.2.0",
  "description": "A lightweight library that provides tools for organizing asynchronous code",
  "main": "node/rsvp.js",
  "directories": {
    "lib": "lib"
  },
  "devDependencies": {
    "jshint": "~0.9",
    "promise-tests": "2.0.0",
    "uglify-js": "~2.2"
  },
  "scripts": {
    "test": "promise-tests all ./tests/test-adapter",
    "lint": "jshint lib"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/tildeio/rsvp.js.git"
  },
  "bugs": {
    "url": "https://github.com/tildeio/rsvp.js/issues"
  },
  "keywords": [
    "promises",
    "futures",
    "events"
  ],
  "author": {
    "name": "Tilde, Inc."
  },
  "license": "MIT",
  "readme": "# RSVP.js\n\nRSVP.js provides simple tools for organizing asynchronous code.\n\nSpecifically, it is a tiny implementation of Promises/A and a\nmixin for turning objects into event targets.\n\nIt works in node and the browser. You can get the browser build in\n`browser/rsvp.js` and `browser/rsvp.min.js`.\n\n## Promises\n\n`RSVP.Promise` is an implementation of\n[Promises/A](http://wiki.commonjs.org/wiki/Promises/A) that passes the\n[promises test suite](https://github.com/domenic/promise-tests) written\nby Domenic Denicola.\n\nIt passes both the primary suite, which tests explicit compliance with\nthe Promises/A spec, and the extension tests, which test compliance with\ncommonly accepted practices around promises in JavaScript.\n\nIt delivers all promises asynchronously, even if the value is already\navailable, to help you write consistent code that doesn't change if the\nunderlying data provider changes from synchronous to asynchronous.\n\nIt is compatible with [TaskJS](http://taskjs.org/), a library by Dave\nHerman of Mozilla that uses ES6 generators to allow you to write\nsynchronous code with promises. It currently works in Firefox, and will\nwork in any browser that adds support for ES6 generators. See the\nsection below on TaskJS for more information.\n\n### Basic Usage\n\n```javascript\nvar promise = new Promise();\n\npromise.then(function(value) {\n  // success\n}, function(value) {\n  // failure\n});\n\n// later...\n\npromise.resolve(value) // triggers first callback\npromise.reject(error) // triggers second callback\n```\n\nOnce a promise has been resolved or rejected, it cannot be resolved or\nrejected again.\n\nHere is an example of a simple XHR2 wrapper written using RSVP.js:\n\n```javascript\nvar getJSON = function(url) {\n  var promise = new RSVP.Promise();\n\n  var client = new XMLHttpRequest();\n  client.open(\"GET\", url);\n  client.onreadystatechange = handler;\n  client.responseType = \"json\";\n  client.setRequestHeader(\"Accept\", \"application/json\");\n  client.send();\n\n  function handler() {\n    if (this.readyState === this.DONE) {\n      if (this.status === 200) { promise.resolve(this.response); }\n      else { promise.reject(this); }\n    }\n  };\n\n  return promise;\n};\n\ngetJSON(\"/posts.json\").then(function(json) {\n  // continue\n}, function(error) {\n  // handle errors\n});\n```\n\n### Chaining\n\nOne of the really awesome features of Promises/A promises are that they\ncan be chained together. In other words, the return value of the first\nresolve handler will be passed to the second resolve handler.\n\nIf you return a regular value, it will be passed, as is, to the next\nhandler.\n\n```javascript\ngetJSON(\"/posts.json\").then(function(json) {\n  return json.post;\n}).then(function(post) {\n  // proceed\n});;\n```\n\nThe really awesome part comes when you return a promise from the first\nhandler:\n\n```javascript\ngetJSON(\"/post/1.json\").then(function(post) {\n  // save off post\n  return getJSON(post.commentURL);\n}).then(function(comments) {\n  // proceed with access to posts and comments\n});;\n```\n\nThis allows you to flatten out nested callbacks, and is the main feature\nof promises that prevents \"rightward drift\" in programs with a lot of\nasynchronous code.\n\nErrors also propagate:\n\n```javascript\ngetJSON(\"/posts.json\").then(function(posts) {\n\n}).then(null, function(error) {\n  // even though no error callback was passed to the\n  // first `.then`, the error propagates\n});\n```\n\nYou can use this to emulate `try/catch` logic in synchronous code.\nSimply chain as many resolve callbacks as a you want, and add a failure\nhandler at the end to catch errors.\n\n```javascript\ngetJSON(\"/post/1.json\").then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function(comments) {\n  // proceed with access to posts and comments\n}).then(null, function(error) {\n  // handle errors in either of the two requests\n});\n```\n\n## Arrays of promises\n\nSometimes you might want to work with many promises at once. If you\npass an array of promises to the `all()` method it will return a new\npromise that will be fulfilled when all of the promises in the array\nhave been fulfilled; or rejected immediately if any promise in the array\nis rejected.\n\n```javascript\nvar postIds = [2, 3, 5, 7, 11, 13];\nvar promises = [];\n\nfor(var i = 0; i < postIds.length; i++) {\n\tpromises.push(getJSON(\"/post/\" + postIds[i] + \".json\"));\n}\n\nRSVP.all(promises).then(function(posts) {\n\t// posts contains an array of results for the given promises\n});\n```\n\n## TaskJS\n\nThe [TaskJS](http://taskjs.org/) library makes it possible to take\npromises-oriented code and make it synchronous using ES6 generators.\n\nLet's review an earlier example:\n\n```javascript\ngetJSON(\"/post/1.json\").then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function(comments) {\n  // proceed with access to posts and comments\n}).then(null, function(error) {\n  // handle errors in either of the two requests\n});\n```\n\nWithout any changes to the implementation of `getJSON`, you could write\nthe following code with TaskJS:\n\n```javascript\nspawn(function *() {\n  try {\n    var post = yield getJSON(\"/post/1.json\");\n    var comments = yield getJSON(post.commentURL);\n  } catch(error) {\n    // handle errors\n  }\n});\n```\n\nIn the above example, `function *` is new syntax in ES6 for\n[generators](http://wiki.ecmascript.org/doku.php?id=harmony:generators).\nInside a generator, `yield` pauses the generator, returning control to\nthe function that invoked the generator. In this case, the invoker is a\nspecial function that understands the semantics of Promises/A, and will\nautomatically resume the generator as soon as the promise is resolved.\n\nThe cool thing here is the same promises that work with current\nJavaScript using `.then` will work seamlessly with TaskJS once a browser\nhas implemented it!\n\n## Event Target\n\nRSVP also provides a mixin that you can use to convert any object into\nan event target. The promises implementation uses `RSVP.EventTarget`, so\n`RSVP` exposes it for your own use.\n\n### Basic Usage\n\nThe basic usage of `RSVP.EventTarget` is to mix it into an object, then\nuse `on` and `trigger` to register listeners and trigger them.\n\n```javascript\nvar object = {};\n\nRSVP.EventTarget.mixin(object);\n\nobject.on(\"finished\", function(event) {\n  // handle event\n});\n\nobject.trigger(\"finished\", { detail: value });\n```\n\n### Prototypes\n\nYou can mix `RSVP.EventTarget` into a prototype and it will work as\nexpected.\n\n```javascript\nvar Person = function() {};\nRSVP.EventTarget.mixin(Person.prototype);\n\nvar yehuda = new Person();\nvar tom = new Person();\n\nyehuda.on(\"poke\", function(event) {\n  console.log(\"Yehuda says OW\");\n});\n\ntom.on(\"poke\", function(event) {\n  console.log(\"Tom says OW\");\n});\n\nyehuda.trigger(\"poke\");\ntom.trigger(\"poke\");\n```\n\nThe example will work as expected. If you mix `RSVP.EventTarget` into a\nconstructor's prototype, each instance of that constructor will get its\nown callbacks.\n",
  "readmeFilename": "README.md",
  "_id": "rsvp@1.2.0",
  "dist": {
    "shasum": "be1624c5ad2aafb2c68400ae7d2ebba79364ac72"
  },
  "_from": "rsvp@~1.2.0",
  "_resolved": "https://registry.npmjs.org/rsvp/-/rsvp-1.2.0.tgz"
}
